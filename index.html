<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arbitragem com Flash Loan Otimizada</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.0.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://unpkg.com/@uniswap/sdk@3.0.1/dist/uniswap-sdk.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }
        button, input { margin: 10px 0; }
        .error { color: red; }
        .success { color: green; }
    </style>
</head>
<body>
    <h1>Arbitragem com Flash Loan Otimizada</h1>
    <button id="connectWallet">Connect Wallet</button>
    <p>Token Pair: USDC/WETH</p>
    <input type="number" id="loanAmount" placeholder="Enter Amount" min="0" step="0.01">
    <p>USD Amount: <span id="usdAmount">0</span></p>
    <p>Lender Fee (0.09%): <span id="lenderFee">0</span></p>
    <p>Payback Amount: <span id="paybackAmount">0</span></p>
    <p>Slippage: <input type="number" id="slippage" value="0.5" min="0.1" max="5" step="0.1">%</p>
    <p>Profit: <span id="profit">0</span>%</p>
    <p>Profit Amount: <span id="profitAmount">0</span></p>
    <p id="status"></p>
    <button id="executeArbitrage" disabled>Execute Arbitrage</button>

    <script>
        const contractAddress = '0xf3feaE30F6D823fE03A276DF19c50cBb36A822EE';
        const contractABI = [{"inputs":[{"internalType":"address","name":"_addressProvider","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"ADDRESSES_PROVIDER","outputs":[{"internalType":"contract IPoolAddressesProvider","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_token","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"},{"internalType":"uint8[]","name":"_dexList","type":"uint8[]"},{"internalType":"address[]","name":"_pairs","type":"address[]"},{"internalType":"uint256","name":"profit","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"bytes","name":"_signature","type":"bytes"}],"name":"ArbitrageOverdome","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"POOL","outputs":[{"internalType":"contract IPool","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"premium","type":"uint256"},{"internalType":"address","name":"initiator","type":"address"},{"internalType":"bytes","name":"params","type":"bytes"}],"name":"executeOperation","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"name":"isValidSign","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"withdrawFunds","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}];

        const USDC_ADDRESS = '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359';
        const WETH_ADDRESS = '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619';
        const UNISWAP_V3_FACTORY_ADDRESS = '0x1F98431c8aD98523631AE4a59f267346ea31F984';
        const UNISWAP_V3_POOL_INIT_CODE_HASH = '0xe34f55d1faba6c8ff9dd2513e707f01fada89cd45d9b1e9de8a837b7bcd3f30b';

        let provider, signer, contract;
        let isChecking = false;

        async function connectWallet() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    contract = new ethers.Contract(contractAddress, contractABI, signer);
                    
                    const network = await provider.getNetwork();
                    if (network.chainId !== 137) { // Polygon MainNet chain ID
                        throw new Error('Please connect to Polygon MainNet');
                    }
                    
                    document.getElementById('connectWallet').textContent = 'Connected';
                    document.getElementById('executeArbitrage').disabled = false;
                    checkArbitrageOpportunity();
                } catch (error) {
                    console.error('Failed to connect wallet:', error);
                    setStatus(error.message, 'error');
                }
            } else {
                setStatus('Please install MetaMask!', 'error');
            }
        }

        async function checkArbitrageOpportunity() {
            if (!contract || isChecking) return;
            isChecking = true;

            try {
                const balance = await provider.getBalance(await signer.getAddress());
                console.log('Wallet Balance:', ethers.utils.formatEther(balance));
                if (balance.lt(ethers.utils.parseEther('0.1'))) {
                    setStatus('Insufficient MATIC balance for network fees', 'error');
                    isChecking = false;
                    return;
                }

                const loanAmount = parseFloat(document.getElementById('loanAmount').value) || 0;
                console.log('Loan Amount:', loanAmount);
                if (loanAmount <= 0) {
                    setStatus('Please enter a valid loan amount', 'error');
                    isChecking = false;
                    return;
                }

                const [priceExchange1, priceExchange2] = await Promise.all([
                    getPriceFromUniswapV3(USDC_ADDRESS, WETH_ADDRESS, loanAmount),
                    getPriceFromUniswapV3(WETH_ADDRESS, USDC_ADDRESS, loanAmount)
                ]);

                console.log('Price Exchange 1:', priceExchange1);
                console.log('Price Exchange 2:', priceExchange2);

                const flashLoanFee = loanAmount * 0.0009;
                const estimatedGasCost = await estimateGasCost();
                const slippage = parseFloat(document.getElementById('slippage').value) / 100;

                const potentialProfit = Math.abs(priceExchange1 - priceExchange2) - flashLoanFee - estimatedGasCost;
                const profitPercentage = (potentialProfit / loanAmount) * 100;

                console.log('Flash Loan Fee:', flashLoanFee);
                console.log('Estimated Gas Cost:', ethers.utils.formatEther(estimatedGasCost));
                console.log('Slippage:', slippage);
                console.log('Potential Profit:', potentialProfit);
                console.log('Profit Percentage:', profitPercentage);

                if (profitPercentage > slippage) {
                    setStatus(`Arbitrage opportunity found! Potential profit: ${potentialProfit.toFixed(4)} USDC (${profitPercentage.toFixed(2)}%)`, 'success');
                    document.getElementById('profit').textContent = profitPercentage.toFixed(2);
                    document.getElementById('profitAmount').textContent = potentialProfit.toFixed(4);
                    document.getElementById('executeArbitrage').disabled = false;
                } else {
                    setStatus('No profitable arbitrage opportunity at the moment', 'error');
                    document.getElementById('profit').textContent = '0';
                    document.getElementById('profitAmount').textContent = '0';
                    document.getElementById('executeArbitrage').disabled = true;
                }
            } catch (error) {
                console.error('Error checking arbitrage opportunity:', error);
                setStatus('Error checking arbitrage opportunity', 'error');
            }

            isChecking = false;
            setTimeout(checkArbitrageOpportunity, 10000);
        }

        async function getPriceFromUniswapV3(tokenIn, tokenOut, amount) {
            const chainId = 137; // Polygon MainNet
            const [tokenInDecimals, tokenOutDecimals] = await Promise.all([
                getTokenDecimals(tokenIn),
                getTokenDecimals(tokenOut)
            ]);

            const amountIn = ethers.utils.parseUnits(amount.toString(), tokenInDecimals);
            const poolAddress = UniswapV3.getPoolAddress(tokenIn, tokenOut, 3000, UNISWAP_V3_FACTORY_ADDRESS, UNISWAP_V3_POOL_INIT_CODE_HASH);

            const pool = new ethers.Contract(poolAddress, UniswapV3.POOL_ABI, provider);
            const slot0 = await pool.slot0();
            const sqrtPriceX96 = slot0.sqrtPriceX96;
            const price = UniswapV3.getPriceFromSqrtPriceX96(sqrtPriceX96, tokenInDecimals, tokenOutDecimals);

            return amountIn.mul(price).div(ethers.utils.parseUnits('1', tokenOutDecimals)).toNumber();
        }

        async function getTokenDecimals(tokenAddress) {
            const token = new ethers.Contract(tokenAddress, ["function decimals() view returns (uint8)"], provider);
            return await token.decimals();
        }

        async function estimateGasCost() {
            const gasPrice = await provider.getGasPrice();
            const estimatedGasLimit = ethers.BigNumber.from('21000'); // Estimativa simplificada
            return gasPrice.mul(estimatedGasLimit);
        }

        async function executeArbitrage() {
            try {
                const loanAmount = ethers.utils.parseUnits(document.getElementById('loanAmount').value, 6); // Assumindo 6 casas decimais para USDC
                const dexList = [0, 1]; // DEX IDs
                const pairs = [USDC_ADDRESS, WETH_ADDRESS];
                const profit = ethers.utils.parseUnits(document.getElementById('profitAmount').textContent, 6);
                const timestamp = Math.floor(Date.now() / 1000);
                const nonce = Math.floor(Math.random() * 1e6);
                const signature = '0x'; // Assinatura vazia para simplificação

                const tx = await contract.ArbitrageOverdome(
                    USDC_ADDRESS,
                    loanAmount,
                    dexList,
                    pairs,
                    profit,
                    timestamp,
                    nonce,
                    signature
                );

                setStatus(`Transaction sent: ${tx.hash}`, 'success');
                await tx.wait();
                setStatus('Arbitrage executed successfully', 'success');
            } catch (error) {
                console.error('Error executing arbitrage:', error);
                setStatus('Error executing arbitrage', 'error');
            }
        }

        function setStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = type;
        }

        document.getElementById('connectWallet').addEventListener('click', connectWallet);
        document.getElementById('loanAmount').addEventListener('input', checkArbitrageOpportunity);
        document.getElementById('executeArbitrage').addEventListener('click', executeArbitrage);
    </script>
</body>
</html>
