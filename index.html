<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arbitragem com Flash Loan Otimizada</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.0.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }
        button, input { margin: 10px 0; }
        .error { color: red; }
        .success { color: green; }
        .info { color: blue; }
        .log { font-size: 0.9em; color: gray; }
    </style>
</head>
<body>
    <h1>Arbitragem com Flash Loan Otimizada</h1>
    <button id="connectWallet">Connect Wallet</button>
    <p>Token Pair: USDC/WETH</p>
    <input type="number" id="loanAmount" placeholder="Enter Amount" min="0" step="0.01">
    <p>USD Amount: <span id="usdAmount">0</span></p>
    <p>Lender Fee (0.09%): <span id="lenderFee">0</span></p>
    <p>Payback Amount: <span id="paybackAmount">0</span></p>
    <p>Slippage: <input type="number" id="slippage" value="0.5" min="0.1" max="5" step="0.1">%</p>
    <p>Profit: <span id="profit">0</span>%</p>
    <p>Profit Amount: <span id="profitAmount">0</span></p>
    <p id="status"></p>
    <button id="executeArbitrage" disabled>Execute Arbitrage</button>
    <h2>Logs</h2>
    <pre id="logs"></pre>
    <h2>Token Values</h2>
    <p>USDC: <span id="usdcValue">0</span></p>
    <p>WETH: <span id="wethValue">0</span></p>

    <script>
        const contractAddress = '0x8F65C155cBFc34C09583a74fEBc581DCd5Cae34E';
        const contractABI = [
            {
                "inputs": [
                    {
                        "internalType": "address[]",
                        "name": "_assets",
                        "type": "address[]"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "_amounts",
                        "type": "uint256[]"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "_modes",
                        "type": "uint256[]"
                    },
                    {
                        "internalType": "bytes",
                        "name": "_params",
                        "type": "bytes"
                    }
                ],
                "name": "executeArbitrage",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address[]",
                        "name": "assets",
                        "type": "address[]"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "amounts",
                        "type": "uint256[]"
                    },
                    {
                        "internalType": "uint256[]",
                        "name": "premiums",
                        "type": "uint256[]"
                    },
                    {
                        "internalType": "bytes",
                        "name": "params",
                        "type": "bytes"
                    }
                ],
                "name": "executeOperation",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_addressesProvider",
                        "type": "address"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_token",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_amount",
                        "type": "uint256"
                    }
                ],
                "name": "withdrawFunds",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "stateMutability": "payable",
                "type": "receive"
            },
            {
                "inputs": [],
                "name": "addressesProvider",
                "outputs": [
                    {
                        "internalType": "contract IPoolAddressesProvider",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "pool",
                "outputs": [
                    {
                        "internalType": "contract IPool",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        const USDC_ADDRESS = '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359';
        const WETH_ADDRESS = '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619';

        let provider, signer, contract;
        let isChecking = false;

        async function connectWallet() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    contract = new ethers.Contract(contractAddress, contractABI, signer);
                    
                    const network = await provider.getNetwork();
                    if (network.chainId !== 137) {
                        throw new Error('Please connect to Polygon MainNet');
                    }
                    
                    document.getElementById('connectWallet').textContent = 'Connected';
                    document.getElementById('executeArbitrage').disabled = false;
                    setStatus('Wallet connected', 'success');
                    log(`Connected to wallet: ${await signer.getAddress()}`);
                    checkArbitrageOpportunity();
                } catch (error) {
                    console.error('Failed to connect wallet:', error);
                    setStatus(error.message, 'error');
                }
            } else {
                setStatus('Please install MetaMask!', 'error');
            }
        }

        async function checkArbitrageOpportunity() {
            if (!contract || isChecking) return;
            isChecking = true;

            try {
                const balance = await provider.getBalance(await signer.getAddress());
                if (balance.lt(ethers.utils.parseEther('0.1'))) {
                    setStatus('Insufficient MATIC balance for network fees', 'error');
                    isChecking = false;
                    return;
                }

                const loanAmount = parseFloat(document.getElementById('loanAmount').value) || 0;
                if (loanAmount <= 0) {
                    setStatus('Please enter a valid loan amount', 'error');
                    isChecking = false;
                    return;
                }

                const [priceUniswapV2, priceUniswapV3] = await Promise.all([
                    getPriceFromUniswapV2(USDC_ADDRESS, WETH_ADDRESS, loanAmount),
                    getPriceFromUniswapV3(USDC_ADDRESS, WETH_ADDRESS, loanAmount)
                ]);

                const flashLoanFee = loanAmount * 0.0009;
                const estimatedGasCost = await estimateGasCost();
                const slippage = parseFloat(document.getElementById('slippage').value) / 100;

                const potentialProfit = Math.max(priceUniswapV3 - priceUniswapV2, priceUniswapV2 - priceUniswapV3) - flashLoanFee - estimatedGasCost;
                const profitPercentage = (potentialProfit / loanAmount) * 100;

                if (profitPercentage > slippage) {
                    setStatus(`Arbitrage opportunity found! Potential profit: ${potentialProfit.toFixed(4)} USDC (${profitPercentage.toFixed(2)}%)`, 'success');
                    document.getElementById('profit').textContent = profitPercentage.toFixed(2);
                    document.getElementById('profitAmount').textContent = potentialProfit.toFixed(4);
                } else {
                    setStatus('No profitable arbitrage opportunity at the moment', 'info');
                }

                document.getElementById('usdAmount').textContent = loanAmount.toFixed(2);
                document.getElementById('lenderFee').textContent = flashLoanFee.toFixed(4);
                document.getElementById('paybackAmount').textContent = (loanAmount + flashLoanFee).toFixed(4);

            } catch (error) {
                console.error('Error checking arbitrage opportunity:', error);
                setStatus('Error checking arbitrage opportunity: ' + error.message, 'error');
            } finally {
                isChecking = false;
                setTimeout(checkArbitrageOpportunity, 10000);
            }
        }

        async function getPriceFromUniswapV2(tokenIn, tokenOut, amount) {
            try {
                const url = 'https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2';
                const query = `
                    {
                        pair(id: "${tokenIn}_${tokenOut}") {
                            token0 {
                                id
                                symbol
                            }
                            token1 {
                                id
                                symbol
                            }
                            reserve0
                            reserve1
                        }
                    }
                `;
                const response = await axios.post(url, { query });
                const data = response.data.data.pair;
                const price = parseFloat(data.reserve1) / parseFloat(data.reserve0);
                return price * amount;
            } catch (error) {
                console.error('Error fetching price from Uniswap V2:', error);
                throw new Error('Network Error while fetching prices');
            }
        }

        async function getPriceFromUniswapV3(tokenIn, tokenOut, amount) {
            // Implementar lógica para obter preço da Uniswap V3
            // Este é um exemplo simplificado, você precisará ajustar de acordo com a API real da Uniswap V3
            return getPriceFromUniswapV2(tokenIn, tokenOut, amount) * 1.001; // Simulando uma pequena diferença
        }

        async function estimateGasCost() {
            try {
                const gasPrice = await provider.getGasPrice();
                const gasLimit = await contract.estimateGas.executeArbitrage(
                    [USDC_ADDRESS],
                    [ethers.utils.parseUnits('1000', 6)], // Exemplo de valor
                    [0],
                    '0x'
                );
                return gasPrice.mul(gasLimit);
            } catch (error) {
                console.error('Error estimating gas cost:', error);
                throw new Error('Network Error while estimating gas cost');
            }
        }

        async function executeArbitrage() {
            const loanAmount = parseFloat(document.getElementById('loanAmount').value) || 0;
            const assets = [USDC_ADDRESS];
            const amounts = [ethers.utils.parseUnits(loanAmount.toString(), 6)];
            const modes = [0]; // 0 for no debt, 1 for stable, 2 for variable

            // Encode the arbitrage parameters
            const arbitrageParams = ethers.utils.defaultAbiCoder.encode(
                ['address', 'address', 'uint256'],
                [USDC_ADDRESS, WETH_ADDRESS, ethers.utils.parseUnits(loanAmount.toString(), 6)]
            );

            try {
                // Estimate gas for the transaction
                const gasEstimate = await contract.estimateGas.executeArbitrage(assets, amounts, modes, arbitrageParams);
                
                // Add a buffer to the gas estimate
                const gasLimit = gasEstimate.mul(120).div(100); // 20% buffer

                const tx = await contract.executeArbitrage(assets, amounts, modes, arbitrageParams, {
                    gasLimit: gasLimit
                });

                setStatus('Executing arbitrage...', 'info');
                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    setStatus('Arbitrage executed successfully!', 'success');
                    log(`Arbitrage executed: TxHash - ${tx.hash}`);
                } else {
                    setStatus('Arbitrage failed', 'error');
                    log(`Arbitrage failed: TxHash - ${tx.hash}`);
                }
            } catch (error) {
                console.error('Error executing arbitrage:', error);
                setStatus('Error executing arbitrage: ' + error.message, 'error');
                log(`Error executing arbitrage: ${error.message}`);
            }
        }

        function setStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = type;
        }

        function log(message) {
            const logsElement = document.getElementById('logs');
            const logMessage = document.createElement('div');
            logMessage.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logMessage.className = 'log';
            logsElement.appendChild(logMessage);
        }

        document.getElementById('connectWallet').addEventListener('click', connectWallet);
        document.getElementById('executeArbitrage').addEventListener('click', executeArbitrage);
        document.getElementById('loanAmount').addEventListener('input', checkArbitrageOpportunity);

        // Fetch and display token values
        async function fetchTokenValues() {
            try {
                const usdcValue = await getPriceFromUniswapV2(USDC_ADDRESS, WETH_ADDRESS, 1);
                const wethValue = await getPriceFromUniswapV2(WETH_ADDRESS, USDC_ADDRESS, 1);
                document.getElementById('usdcValue').textContent = usdcValue.toFixed(6);
                document.getElementById('wethValue').textContent = wethValue.toFixed(6);
            } catch (error) {
                console.error('Error fetching token values:', error);
            }
        }

        fetchTokenValues();
        setInterval(fetchTokenValues, 60000); // Update token values every minute
    </script>
</body>
</html>
